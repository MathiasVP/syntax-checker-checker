module Main where

import QcSyntax
import CheckContains
import qualified Unparse
import qualified BuggyUnparse
import NumberOfNodes
import Test.QuickCheck
import Test.QuickCheck.Monadic
import System.Process
import System.Directory
import System.Environment
import System.IO
import qualified Data.List as List

setupCode :: FilePath -> String
setupCode path =
  unlines [ "(load \"" ++ path ++ "\")"
          , "(printf \"~s\" (check-program (read-file \"testcase.scm\")))" ]

lasts :: Int -> [a] -> [a]
lasts n xs = List.drop (List.length xs - n) xs

-- README: You can restrict the syntactic constructs generated by
-- setting more fields to false. See checkcontains.hs for all the fields.
-- TODO: Accept these from command line
acc :: Accept
acc = CheckContains.acceptAll

restrict :: String -> Accept
restrict s = List.foldr visit CheckContains.acceptAll flags
  where flags = words s
        visit "toplevelform" accepts =
          accepts {topLevelForm = False}
        visit "toplevel-definition" accepts =
          accepts {topLevelDefinition = False}
        visit "toplevel-expression" accepts =
          accepts {topLevelExpression = False}
        visit "expression" accepts =
          accepts {expression = False}
        visit "number" accepts = accepts {number = False}
        visit "boolean" accepts = accepts {boolean = False}
        visit "char" accepts = accepts {ch = False}
        visit "string" accepts = accepts {str = False}
        visit "time" accepts = accepts {time = False}
        visit "if" accepts = accepts {if_ = False}
        visit "and" accepts = accepts
        visit "or" accepts = accepts
        visit "cond" accepts = accepts
        visit "case" accepts = accepts
        visit "let" accepts = accepts
        visit "let*" accepts = accepts
        visit "letrec" accepts = accepts
        visit "begin" accepts = accepts
        visit "unless" accepts = accepts
        visit "quote" accepts = accepts
        visit "application" accepts = accepts
        visit "variable" accepts = accepts
        visit "cond-clause-immediate" accepts = accepts
        visit "cond-clause-guarded" accepts = accepts
        visit "cond-clause-guarded-impl" accepts = accepts
        visit "case-clause" accepts = accepts
        visit "let-binding" accepts = accepts
        visit "let*-binding" accepts = accepts
        visit "letrec-binding" accepts = accepts
        visit "lambda" accepts = accepts
        visit "quote-number" accepts = accepts
        visit "quote-boolean" accepts = accepts
        visit "quote-char" accepts = accepts
        visit "quote-string" accepts = accepts
        visit "quote-symbol" accepts = accepts
        visit "quote-empty" accepts = accepts
        visit "quote-pair" accepts = accepts
        visit flag accepts = error $ "Unregonized flag: " ++ flag



testValidSyntaxChecker :: Program -> Int -> Int -> Property
testValidSyntaxChecker p _ _ =
  not (List.null p) && accepted acc p ==>
    monadicIO $ do
      result <- run $ do
        writeFile "testcase.scm" (Unparse.unparse p)
        putStr "."
        hFlush stdout
        readCreateProcess (shell "petite --script \"runtest.scm\"") ""
      assert $ lasts 2 result == "#t"

testInvalidSyntaxChecker :: Program -> Int -> Int -> Property
testInvalidSyntaxChecker p point seed =
  point > 0 && point <= numberOfNodes p ==>
    monadicIO $ do
      result <- run $ do
        let p' = BuggyUnparse.unparse p point seed
        writeFile "testcase.scm" p'
        putStr "."
        hFlush stdout
        readCreateProcess (shell "petite --script \"runtest.scm\"") ""
      assert $ lasts 2 result == "#t"

usage :: String
usage = unlines ["Usage:\tpath/to/syntax/checker.scm pos|neg n",
                 "\tpos:\tRun positive tests",
                 "\tneg:\tRun negative tests",
                 "\tn:\tNumber of tests"]

main :: IO ()
main = do
  args <- getArgs
  case args of
    [path, b, n] -> do
      writeFile "runtest.scm" (setupCode path)
      let (qcheck, unparser, errormsg) =
            case b of
              "pos" -> (testValidSyntaxChecker,
                        \p _ _ -> Unparse.unparse p,
                        "Rejected valid program:")
              "neg" -> (testInvalidSyntaxChecker,
                        BuggyUnparse.unparse,
                        "Accepted invalid program:")
              _ -> error usage
      res <- quickCheckWithResult
               (stdArgs {chatty = False, maxSuccess = read n, maxDiscardRatio = 100000})
               qcheck
      --removeFile "testcase.scm"
      --removeFile "runtest.scm"
      case res of
        Success {} -> putStrLn "OK"
        GaveUp _ _ output  -> putStrLn output
        Failure _ _ _ _ _ _ _ _ _ out -> do
          -- Ugly way of extracting the failing testcase
          let [p, point, seed] = lines (drop 2 $ reverse $ takeWhile (/= ':') $ reverse out)
              prog = unparser (read p) (read point) (read seed)
          putStrLn errormsg
          putStrLn prog
        _ -> error "An unknown error occured"
    _ -> error usage
